{"version":3,"file":"Dataset.vue_rollup-plugin-vue=script.js","sources":["../../../src/Dataset.vue"],"sourcesContent":["<template>\r\n  <div>\r\n    <slot :ds=\"{ dsShowEntries, dsResultsNumber, dsPage, dsPagecount, dsFrom, dsTo, dsData, dsRows, dsPages }\"></slot>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { ReactiveProvideMixin } from 'vue-reactive-provide';\r\nimport datasetI18n from './i18n/en.js';\r\nimport { isEmptyObject, createPagingRange, fieldSorter, fieldFilter, findAny } from './helpers';\r\n\r\nexport default {\r\n  provide () {\r\n    return {\r\n      search: this.search,\r\n      showEntries: this.showEntries,\r\n      setActive: this.setActive,\r\n      datasetI18n: this.datasetI18n\r\n    };\r\n  },\r\n  mixins: [\r\n    ReactiveProvideMixin({\r\n      name: 'ds',\r\n      include: ['dsData', 'dsRows', 'dsResultsNumber', 'dsFrom', 'dsTo', 'dsPages', 'dsPagecount', 'dsPage']\r\n    })\r\n  ],\r\n  props: {\r\n    dsData: {\r\n      type: Array,\r\n      default: () => []\r\n    },\r\n    dsFilterFields: {\r\n      type: Object,\r\n      default: () => ({})\r\n    },\r\n    dsSortby: {\r\n      type: Array,\r\n      default: () => []\r\n    },\r\n    dsSearchIn: {\r\n      type: Array,\r\n      default: () => []\r\n    },\r\n    dsSearchAs: {\r\n      type: Object,\r\n      default: () => ({})\r\n    },\r\n    dsSortAs: {\r\n      type: Object,\r\n      default: () => ({})\r\n    }\r\n  },\r\n  data: function () {\r\n    return {\r\n      dsPage: 1,\r\n      dsSearch: '',\r\n      dsShowEntries: 10,\r\n      datasetI18n: datasetI18n\r\n    };\r\n  },\r\n  computed: {\r\n    /*\r\n    The naive attempt would be to manipulate the original array directly.\r\n    This is problematic because it has to be filtered first, then sorted, then the from/to rows extracted.\r\n    In order to do that in that order, you would need to work on a copy.\r\n    But this is problematic as well since you'd loose the data-binding with the original array.\r\n\r\n    The trick is to work directly on the array indexes.\r\n    */\r\n    indexes: function () {\r\n      let result = [];\r\n      const dsData = this.dsData;\r\n      const dsSearch = this.dsSearch;\r\n      const dsSortby = this.dsSortby;\r\n      const dsFilterFields = this.dsFilterFields;\r\n      const dsSearchIn = this.dsSearchIn;\r\n      const dsSearchAs = this.dsSearchAs;\r\n      const dsSortAs = this.dsSortAs;\r\n\r\n      if (!dsSearch && !dsSortby.length && isEmptyObject(dsFilterFields)) {\r\n        // Just get the indexes\r\n        result = dsData.map(function (val, i) {\r\n          return i;\r\n        });\r\n      } else {\r\n        // Index it\r\n        result = dsData.map(function (val, i) {\r\n          return { index: i, value: val };\r\n        });\r\n\r\n        // Filter it by field\r\n        if (!isEmptyObject(dsFilterFields)) {\r\n          result = fieldFilter(result, dsFilterFields);\r\n        }\r\n\r\n        // Search it\r\n        if (dsSearch) {\r\n          result = result.filter(function (entry) {\r\n            return findAny(dsSearchIn, dsSearchAs, entry.value, dsSearch);\r\n          });\r\n        }\r\n\r\n        // Sort it\r\n        if (dsSortby.length) {\r\n          result.sort(fieldSorter(dsSortby, dsSortAs));\r\n        }\r\n\r\n        // We need indexes only\r\n        result = result.map(function (entry) {\r\n          return entry.index;\r\n        });\r\n      }\r\n      return result;\r\n    },\r\n    dsRows: function () {\r\n      // We should not modify another computed property from inside a computed property\r\n      // This should be moved into the dsTo computed if needed\r\n      /*\r\n      if (this.dsTo <= 0) {\r\n        this.dsTo = this.indexes.length;\r\n      }\r\n      */\r\n      // console.log(this.indexes);\r\n      return this.indexes.slice(this.dsFrom, this.dsTo);\r\n    },\r\n    dsPages: function () {\r\n      return createPagingRange(this.dsPagecount, this.dsPage);\r\n    },\r\n    dsResultsNumber: function () {\r\n      return this.indexes.length;\r\n    },\r\n    dsPagecount: function () {\r\n      return Math.ceil(this.dsResultsNumber / this.dsShowEntries);\r\n    },\r\n    dsFrom: function () {\r\n      return (this.dsPage - 1) * this.dsShowEntries;\r\n    },\r\n    dsTo: function () {\r\n      return this.dsPage * this.dsShowEntries;\r\n    }\r\n  },\r\n  watch: {\r\n    dsResultsNumber: {\r\n      handler: function (val, oldVal) {\r\n        // Reset active page when results change\r\n        this.setActive(1);\r\n      }\r\n    }\r\n  },\r\n  methods: {\r\n    search (value) {\r\n      this.dsSearch = value;\r\n    },\r\n    showEntries (value) {\r\n      const pagesBeforeChange = this.dsPages;\r\n      this.dsShowEntries = value;\r\n      this.$nextTick(() => {\r\n        const pagesAfterChange = this.dsPages;\r\n        if (pagesAfterChange.length < pagesBeforeChange.length) {\r\n          this.setActive(pagesAfterChange[pagesAfterChange.length - 1]);\r\n        }\r\n      });\r\n    },\r\n    setActive (value) {\r\n      this.dsPage = value;\r\n    }\r\n  }\r\n};\r\n</script>\r\n"],"names":[],"mappings":";;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;"}