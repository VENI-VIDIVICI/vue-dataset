{"version":3,"file":"Dataset.js","sources":["../../src/i18n/en.js","../../src/Dataset.vue"],"sourcesContent":["export default {\n  show: 'Show',\n  entries: 'entries',\n  previous: 'Previous',\n  next: 'Next',\n  showing: 'Showing',\n  showingTo: 'to',\n  showingOf: 'of',\n  showingEntries: 'entries'\n}\n","<template>\n  <div>\n    <slot :ds=\"{ dsShowEntries, dsResultsNumber, dsPage, dsPagecount, dsFrom, dsTo, dsData, dsRows, dsPages }\"></slot>\n  </div>\n</template>\n\n<script>\nimport datasetI18n from './i18n/en.js'\nimport { isEmptyObject, createPagingRange, fieldSorter, fieldFilter, findAny } from './helpers'\n\nexport default {\n  provide() {\n    return {\n      search: this.search,\n      showEntries: this.showEntries,\n      setActive: this.setActive,\n      datasetI18n: this.datasetI18n,\n      /* Setup reactive provides */\n      rdsData: () => this.dsData,\n      rdsRows: () => this.dsRows,\n      rdsPages: () => this.dsPages,\n      rdsResultsNumber: () => this.dsResultsNumber,\n      rdsPagecount: () => this.dsPagecount,\n      rdsFrom: () => this.dsFrom,\n      rdsTo: () => this.dsTo,\n      rdsPage: () => this.dsPage\n    }\n  },\n  props: {\n    dsData: {\n      type: Array,\n      default: () => []\n    },\n    dsFilterFields: {\n      type: Object,\n      default: () => ({})\n    },\n    dsSortby: {\n      type: Array,\n      default: () => []\n    },\n    dsSearchIn: {\n      type: Array,\n      default: () => []\n    },\n    dsSearchAs: {\n      type: Object,\n      default: () => ({})\n    },\n    dsSortAs: {\n      type: Object,\n      default: () => ({})\n    }\n  },\n  data: function () {\n    return {\n      dsPage: 1,\n      dsSearch: '',\n      dsShowEntries: 10,\n      datasetI18n: datasetI18n\n    }\n  },\n  computed: {\n    /*\n    The naive attempt would be to manipulate the original array directly.\n    This is problematic because it has to be filtered first, then sorted, then the from/to rows extracted.\n    In order to do that in that order, you would need to work on a copy.\n    But this is problematic as well since you'd loose the data-binding with the original array.\n\n    The trick is to work directly on the array indexes.\n    */\n    indexes: function () {\n      let result = []\n      const dsData = this.dsData\n      const dsSearch = this.dsSearch\n      const dsSortby = this.dsSortby\n      const dsFilterFields = this.dsFilterFields\n      const dsSearchIn = this.dsSearchIn\n      const dsSearchAs = this.dsSearchAs\n      const dsSortAs = this.dsSortAs\n\n      if (!dsSearch && !dsSortby.length && isEmptyObject(dsFilterFields)) {\n        // Just get the indexes\n        result = dsData.map(function (val, i) {\n          return i\n        })\n      } else {\n        // Index it\n        result = dsData.map(function (val, i) {\n          return { index: i, value: val }\n        })\n\n        // Filter it by field\n        if (!isEmptyObject(dsFilterFields)) {\n          result = fieldFilter(result, dsFilterFields)\n        }\n\n        // Search it\n        if (dsSearch) {\n          result = result.filter(function (entry) {\n            return findAny(dsSearchIn, dsSearchAs, entry.value, dsSearch)\n          })\n        }\n\n        // Sort it\n        if (dsSortby.length) {\n          result.sort(fieldSorter(dsSortby, dsSortAs))\n        }\n\n        // We need indexes only\n        result = result.map(function (entry) {\n          return entry.index\n        })\n      }\n      return result\n    },\n    dsRows: function () {\n      // We should not modify another computed property from inside a computed property\n      // This should be moved into the dsTo computed if needed\n      /*\n      if (this.dsTo <= 0) {\n        this.dsTo = this.indexes.length;\n      }\n      */\n      // console.log(this.indexes);\n      return this.indexes.slice(this.dsFrom, this.dsTo)\n    },\n    dsPages: function () {\n      return createPagingRange(this.dsPagecount, this.dsPage)\n    },\n    dsResultsNumber: function () {\n      return this.indexes.length\n    },\n    dsPagecount: function () {\n      return Math.ceil(this.dsResultsNumber / this.dsShowEntries)\n    },\n    dsFrom: function () {\n      return (this.dsPage - 1) * this.dsShowEntries\n    },\n    dsTo: function () {\n      return this.dsPage * this.dsShowEntries\n    }\n  },\n  watch: {\n    dsResultsNumber: {\n      handler: function (val, oldVal) {\n        // Reset active page when results change\n        this.setActive(1)\n      }\n    }\n  },\n  methods: {\n    search(value) {\n      this.dsSearch = value\n    },\n    showEntries(value) {\n      const pagesBeforeChange = this.dsPages\n      this.dsShowEntries = value\n      this.$nextTick(() => {\n        const pagesAfterChange = this.dsPages\n        if (pagesAfterChange.length < pagesBeforeChange.length) {\n          this.setActive(pagesAfterChange[pagesAfterChange.length - 1])\n        }\n      })\n    },\n    setActive(value) {\n      this.dsPage = value\n    }\n  }\n}\n</script>\n"],"names":["const"],"mappings":";;;AAAA,kBAAe;AACf,EAAE,IAAI,EAAE,MAAM;AACd,EAAE,OAAO,EAAE,SAAS;AACpB,EAAE,QAAQ,EAAE,UAAU;AACtB,EAAE,IAAI,EAAE,MAAM;AACd,EAAE,OAAO,EAAE,SAAS;AACpB,EAAE,SAAS,EAAE,IAAI;AACjB,EAAE,SAAS,EAAE,IAAI;AACjB,EAAE,cAAc,EAAE,SAAS;AAC3B;;;;ACCA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAvKAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}